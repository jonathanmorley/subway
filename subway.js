// Generated by CoffeeScript 1.6.3
(function() {
  var createLabel, drawGridLines, drawHorizontalLabel, drawHorizontalLine, drawRoute, drawSolidEdge, drawStation, drawVerticalLabel, drawVerticalLine, getStartEndPoint, map,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  map = {
    grid: {
      rows: 6,
      columns: 9,
      color: "#00B3EF"
    },
    border: 10,
    base_radius: 5
  };

  $(function() {
    var paper;
    map.height = 100 * Math.floor($("#map").height() / 100);
    map.width = 100 * Math.floor($("#map").width() / 100);
    map.multiplier = Math.min(map.height, map.width) / 1000;
    map.grid.length = Math.min(map.width / map.grid.columns, map.height / map.grid.rows);
    paper = Raphael("map", map.width + 2 * map.border, map.height + 2 * map.border);
    drawGridLines(paper);
    return $.getJSON(data, function(data) {
      var route, station, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.routes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        route = _ref[_i];
        if (route.name === "test") {
          drawRoute(paper, route);
        }
      }
      _ref1 = data.stations;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        station = _ref1[_j];
        _results.push(drawStation(paper, station));
      }
      return _results;
    });
  });

  drawGridLines = function(paper) {
    var i, _i, _j, _k, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results, _results1, _results2;
    for (i = _i = 0, _ref = map.grid.rows; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      drawHorizontalLine(paper, map.border + i * map.grid.length, __indexOf.call((function() {
        _results = [];
        for (var _j = 1, _ref1 = map.grid.rows; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; 1 <= _ref1 ? _j++ : _j--){ _results.push(_j); }
        return _results;
      }).apply(this), i) >= 0 ? 0.25 : 1);
    }
    for (i = _k = 0, _ref2 = map.grid.columns; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
      drawVerticalLine(paper, map.border + i * map.grid.length, __indexOf.call((function() {
        _results1 = [];
        for (var _l = 1, _ref3 = map.grid.columns; 1 <= _ref3 ? _l < _ref3 : _l > _ref3; 1 <= _ref3 ? _l++ : _l--){ _results1.push(_l); }
        return _results1;
      }).apply(this), i) >= 0 ? 0.25 : 1);
    }
    for (i = _m = 1, _ref4 = map.grid.columns; 1 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 1 <= _ref4 ? ++_m : --_m) {
      drawHorizontalLabel(paper, i);
    }
    _results2 = [];
    for (i = _n = 1, _ref5 = map.grid.rows; 1 <= _ref5 ? _n <= _ref5 : _n >= _ref5; i = 1 <= _ref5 ? ++_n : --_n) {
      _results2.push(drawVerticalLabel(paper, i));
    }
    return _results2;
  };

  drawHorizontalLine = function(paper, position, width) {
    return paper.path(Raphael.format("M{0},{1}l{2},0", map.border, position, map.grid.length * map.grid.columns)).attr("stroke", map.grid.color).attr("stroke-width", map.multiplier * width);
  };

  drawVerticalLine = function(paper, position, width) {
    return paper.path(Raphael.format("M{0},{1}l0,{2}", position, map.border, map.grid.length * map.grid.rows)).attr("stroke", map.grid.color).attr("stroke-width", map.multiplier * width);
  };

  drawHorizontalLabel = function(paper, x) {
    return createLabel(paper, x).forEach(function(elem) {
      return elem.transform(Raphael.format("t{0},{1}", map.border + (x - 0.5) * map.grid.length, map.border));
    }).forEach(function(elem) {
      return elem.clone().transform(Raphael.format("t{0},{1}", map.border + (x - 0.5) * map.grid.length, map.border + map.grid.rows * map.grid.length));
    });
  };

  drawVerticalLabel = function(paper, x) {
    return createLabel(paper, String.fromCharCode(x + 64)).forEach(function(elem) {
      return elem.transform(Raphael.format("t{0},{1}", map.border, map.border + (x - 0.5) * map.grid.length));
    }).forEach(function(elem) {
      return elem.clone().transform(Raphael.format("t{0},{1}", map.border + map.grid.columns * map.grid.length, map.border + (x - 0.5) * map.grid.length));
    });
  };

  createLabel = function(paper, label) {
    var clearbox;
    clearbox = {
      attr: {
        stroke: "white",
        fill: "white"
      },
      height: map.multiplier * 12,
      width: map.multiplier * 8
    };
    paper.setStart();
    paper.rect(-clearbox.width / 2, -clearbox.height / 2, clearbox.width, clearbox.height).attr(clearbox.attr);
    paper.text(0, 0, label).attr("fill", map.grid.color).attr("font-size", map.multiplier * 13);
    return paper.setFinish();
  };

  drawRoute = function(paper, route) {
    var edge, key, value, _i, _len, _ref, _ref1;
    _ref = route.translate;
    for (key in _ref) {
      value = _ref[key];
      route.translate[key] = value * map.multiplier;
    }
    _ref1 = getStartEndPoint(route.edges);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      edge = _ref1[_i];
      drawSolidEdge(paper, edge).transform(Raphael.fullfill("t{x},{y}", route.translate));
    }
    return console.log(getStartEndPoint(route.edges));
  };

  drawSolidEdge = function(paper, edge) {
    return paper.path(Raphael.fullfill("M{start.x},{start.y}L{end.x},{end.y}", edge)).attr("stroke-width", map.multiplier * 10);
  };

  drawStation = function(paper, station) {
    return console.log(station);
  };

  getStartEndPoint = function(edges) {
    var current, edge, index, values, _i, _len, _results;
    current = {
      x: 0,
      y: 0
    };
    _results = [];
    for (index = _i = 0, _len = edges.length; _i < _len; index = ++_i) {
      edge = edges[index];
      _results.push(values = {
        start: {
          x: Math.round(edge.follow ? current.x = _results[edge.follow].end.x : current.x),
          y: Math.round(edge.follow ? current.y = _results[edge.follow].end.y : current.y),
          curve: __indexOf.call(edges.slice(1), edge) >= 0 && edges[index - 1].direction !== edge.direction
        },
        end: {
          x: current.x += Math.round(edge.length * map.multiplier * Math.sin(edge.direction * (Math.PI / 4))),
          y: current.y += Math.round(edge.length * map.multiplier * -Math.cos(edge.direction * (Math.PI / 4))),
          curve: __indexOf.call(edges.slice(0, -1), edge) >= 0 && (edges[index + 1].follow == null) && edges[index + 1].direction !== edge.direction
        }
      });
    }
    return _results;
  };

}).call(this);
