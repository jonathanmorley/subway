// Generated by CoffeeScript 1.6.3
(function() {
  var createLabel, drawGridLines, drawHorizontalLabel, drawHorizontalLine, drawRoute, drawSolidCurve, drawSolidEdge, drawStation, drawVerticalLabel, drawVerticalLine, getCurvedEdges, getCurves, getFullEdges, map,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  map = {
    grid: {
      rows: 6,
      columns: 9,
      color: "#00B3EF"
    },
    border: 10,
    base_radius: 15
  };

  $(function() {
    var paper;
    map.height = 100 * Math.floor($("#map").height() / 100);
    map.width = 100 * Math.floor($("#map").width() / 100);
    map.multiplier = Math.min(map.height, map.width) / 1000;
    map.grid.length = Math.min(map.width / map.grid.columns, map.height / map.grid.rows);
    paper = Raphael("map", map.width + 2 * map.border, map.height + 2 * map.border);
    drawGridLines(paper);
    return $.getJSON(data, function(data) {
      var route, station, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.routes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        route = _ref[_i];
        if (route.name === "test") {
          drawRoute(paper, route);
        }
      }
      _ref1 = data.stations;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        station = _ref1[_j];
        _results.push(drawStation(paper, station));
      }
      return _results;
    });
  });

  drawGridLines = function(paper) {
    var i, _i, _j, _k, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results, _results1, _results2;
    for (i = _i = 0, _ref = map.grid.rows; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      drawHorizontalLine(paper, map.border + i * map.grid.length, __indexOf.call((function() {
        _results = [];
        for (var _j = 1, _ref1 = map.grid.rows; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; 1 <= _ref1 ? _j++ : _j--){ _results.push(_j); }
        return _results;
      }).apply(this), i) >= 0 ? 0.25 : 1);
    }
    for (i = _k = 0, _ref2 = map.grid.columns; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
      drawVerticalLine(paper, map.border + i * map.grid.length, __indexOf.call((function() {
        _results1 = [];
        for (var _l = 1, _ref3 = map.grid.columns; 1 <= _ref3 ? _l < _ref3 : _l > _ref3; 1 <= _ref3 ? _l++ : _l--){ _results1.push(_l); }
        return _results1;
      }).apply(this), i) >= 0 ? 0.25 : 1);
    }
    for (i = _m = 1, _ref4 = map.grid.columns; 1 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 1 <= _ref4 ? ++_m : --_m) {
      drawHorizontalLabel(paper, i);
    }
    _results2 = [];
    for (i = _n = 1, _ref5 = map.grid.rows; 1 <= _ref5 ? _n <= _ref5 : _n >= _ref5; i = 1 <= _ref5 ? ++_n : --_n) {
      _results2.push(drawVerticalLabel(paper, i));
    }
    return _results2;
  };

  drawHorizontalLine = function(paper, position, width) {
    return paper.path(Raphael.format("M{0},{1}l{2},0", map.border, position, map.grid.length * map.grid.columns)).attr("stroke", map.grid.color).attr("stroke-width", map.multiplier * width);
  };

  drawVerticalLine = function(paper, position, width) {
    return paper.path(Raphael.format("M{0},{1}l0,{2}", position, map.border, map.grid.length * map.grid.rows)).attr("stroke", map.grid.color).attr("stroke-width", map.multiplier * width);
  };

  drawHorizontalLabel = function(paper, x) {
    return createLabel(paper, x).forEach(function(elem) {
      return elem.transform(Raphael.format("t{0},{1}", map.border + (x - 0.5) * map.grid.length, map.border));
    }).forEach(function(elem) {
      return elem.clone().transform(Raphael.format("t{0},{1}", map.border + (x - 0.5) * map.grid.length, map.border + map.grid.rows * map.grid.length));
    });
  };

  drawVerticalLabel = function(paper, x) {
    return createLabel(paper, String.fromCharCode(x + 64)).forEach(function(elem) {
      return elem.transform(Raphael.format("t{0},{1}", map.border, map.border + (x - 0.5) * map.grid.length));
    }).forEach(function(elem) {
      return elem.clone().transform(Raphael.format("t{0},{1}", map.border + map.grid.columns * map.grid.length, map.border + (x - 0.5) * map.grid.length));
    });
  };

  createLabel = function(paper, label) {
    var clearbox;
    clearbox = {
      attr: {
        stroke: "white",
        fill: "white"
      },
      height: map.multiplier * 12,
      width: map.multiplier * 8
    };
    paper.setStart();
    paper.rect(-clearbox.width / 2, -clearbox.height / 2, clearbox.width, clearbox.height).attr(clearbox.attr);
    paper.text(0, 0, label).attr("fill", map.grid.color).attr("font-size", map.multiplier * 13);
    return paper.setFinish();
  };

  drawRoute = function(paper, route) {
    var curve, curved_edges, curves, edge, full_edges, key, value, _i, _j, _len, _len1, _ref, _results;
    _ref = route.translate;
    for (key in _ref) {
      value = _ref[key];
      route.translate[key] = value * map.multiplier;
    }
    curved_edges = getCurvedEdges(route.vectors);
    full_edges = getFullEdges(route.vectors);
    curves = getCurves(curved_edges, full_edges);
    console.log(curves);
    for (_i = 0, _len = curved_edges.length; _i < _len; _i++) {
      edge = curved_edges[_i];
      drawSolidEdge(paper, edge).transform(Raphael.fullfill("t{x},{y}", route.translate));
    }
    _results = [];
    for (_j = 0, _len1 = curves.length; _j < _len1; _j++) {
      curve = curves[_j];
      _results.push(drawSolidCurve(paper, curve).transform(Raphael.fullfill("t{x},{y}", route.translate)));
    }
    return _results;
  };

  drawSolidEdge = function(paper, edge) {
    return paper.path(Raphael.fullfill("M{start.x},{start.y}L{end.x},{end.y}", edge)).attr("stroke-width", map.multiplier * 10);
  };

  drawSolidCurve = function(paper, curve) {
    return paper.path(Raphael.fullfill("M{start.x},{start.y}S{control.x},{control.y},{end.x},{end.y}", curve)).attr("stroke-width", map.multiplier * 10);
  };

  drawStation = function(paper, station) {
    return console.log(station);
  };

  getFullEdges = function(vectors) {
    var current, index, vector, _i, _len, _results;
    current = {
      x: 0,
      y: 0
    };
    _results = [];
    for (index = _i = 0, _len = vectors.length; _i < _len; index = ++_i) {
      vector = vectors[index];
      _results.push({
        start: {
          x: (vector.follow ? current.x = _results[vector.follow].end.x : current.x),
          y: (vector.follow ? current.y = _results[vector.follow].end.y : current.y)
        },
        end: {
          x: (current.x += Math.round(vector.length * map.multiplier * Math.sin(vector.direction * (Math.PI / 4)))),
          y: (current.y += Math.round(vector.length * map.multiplier * -Math.cos(vector.direction * (Math.PI / 4))))
        }
      });
    }
    return _results;
  };

  getCurvedEdges = function(vectors) {
    var current, index, vector, _i, _len, _results;
    current = {
      x: 0,
      y: 0
    };
    _results = [];
    for (index = _i = 0, _len = vectors.length; _i < _len; index = ++_i) {
      vector = vectors[index];
      _results.push({
        start: {
          x: (vector.follow ? current.x = _results[vector.follow].end.x : current.x) + (__indexOf.call(vectors.slice(1), vector) >= 0 && vectors[index - 1].direction !== vector.direction ? Math.round(map.base_radius * map.multiplier * Math.sin(vector.direction * (Math.PI / 4))) : 0),
          y: (vector.follow ? current.y = _results[vector.follow].end.y : current.y) + (__indexOf.call(vectors.slice(1), vector) >= 0 && vectors[index - 1].direction !== vector.direction ? Math.round(map.base_radius * map.multiplier * -Math.cos(vector.direction * (Math.PI / 4))) : 0)
        },
        end: {
          x: (current.x += Math.round(vector.length * map.multiplier * Math.sin(vector.direction * (Math.PI / 4)))) - (__indexOf.call(vectors.slice(0, -1), vector) >= 0 && (vectors[index + 1].follow == null) && vectors[index + 1].direction !== vector.direction ? Math.round(map.base_radius * map.multiplier * Math.sin(vector.direction * (Math.PI / 4))) : 0),
          y: (current.y += Math.round(vector.length * map.multiplier * -Math.cos(vector.direction * (Math.PI / 4)))) - (__indexOf.call(vectors.slice(0, -1), vector) >= 0 && (vectors[index + 1].follow == null) && vectors[index + 1].direction !== vector.direction ? Math.round(map.base_radius * map.multiplier * -Math.cos(vector.direction * (Math.PI / 4))) : 0)
        }
      });
    }
    return _results;
  };

  getCurves = function(curved_edges, full_edges) {
    var curves, edge, index, _i, _len, _ref, _results;
    _ref = curved_edges.slice(0, -1);
    _results = [];
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      edge = _ref[index];
      if (edge.end !== curved_edges[index + 1].start) {
        _results.push(curves = {
          start: edge.end,
          end: curved_edges[index + 1].start,
          control: full_edges[index].end
        });
      }
    }
    return _results;
  };

}).call(this);
