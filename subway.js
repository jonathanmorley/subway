// Generated by CoffeeScript 1.6.3
(function() {
  var drawGridLines, drawRoute, drawSolidEdge, drawStation, getStartEndPoint, map,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  map = {
    grid: {
      rows: 6,
      columns: 9,
      color: "#00B3EF"
    },
    border: 10
  };

  $(function() {
    var paper;
    map.height = 100 * Math.floor($("#map").height() / 100);
    map.width = 100 * Math.floor($("#map").width() / 100);
    map.multiplier = Math.min(map.height, map.width) / 1000;
    paper = Raphael("map", map.width + 2 * map.border, map.height + 2 * map.border);
    drawGridLines(paper);
    return $.getJSON(data, function(data) {
      var route, station, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.routes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        route = _ref[_i];
        drawRoute(paper, route);
      }
      _ref1 = data.stations;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        station = _ref1[_j];
        _results.push(drawStation(paper, station));
      }
      return _results;
    });
  });

  drawGridLines = function(paper) {
    var cell_length, clearbox, x, _i, _j, _k, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    cell_length = Math.min(map.width / map.grid.columns, map.height / map.grid.rows);
    for (x = _i = 1, _ref = map.grid.columns; 1 <= _ref ? _i < _ref : _i > _ref; x = 1 <= _ref ? ++_i : --_i) {
      paper.path(Raphael.format("M{0},{1}l0,{2}", map.border + x * cell_length, map.border, cell_length * map.grid.rows)).attr("stroke", map.grid.color).attr("stroke-width", map.multiplier * 0.25);
    }
    for (x = _j = 1, _ref1 = map.grid.rows; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 1 <= _ref1 ? ++_j : --_j) {
      paper.path(Raphael.format("M{1},{0}l{2},0", map.border + x * cell_length, map.border, cell_length * map.grid.columns)).attr("stroke", map.grid.color).attr("stroke-width", map.multiplier * 0.25);
    }
    clearbox = {
      attr: {
        stroke: "white",
        fill: "white"
      },
      height: map.multiplier * 12,
      width: map.multiplier * 8
    };
    paper.setStart();
    paper.path(Raphael.format("M{0},{0}l{1},0", map.border, cell_length * map.grid.columns)).attr("stroke", map.grid.color).attr("stroke-width", map.multiplier * 1);
    for (x = _k = 0, _ref2 = map.grid.columns; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; x = 0 <= _ref2 ? ++_k : --_k) {
      paper.rect(map.border + ((x - 0.5) * cell_length) - (clearbox.width / 2), map.border - clearbox.height / 2, clearbox.width, clearbox.height).attr(clearbox.attr);
    }
    for (x = _l = 1, _ref3 = map.grid.columns; 1 <= _ref3 ? _l <= _ref3 : _l >= _ref3; x = 1 <= _ref3 ? ++_l : --_l) {
      paper.text(map.border + (x - 0.5) * cell_length, map.border, x).attr("fill", map.grid.color).attr("font-size", map.multiplier * 13);
    }
    paper.setFinish().forEach(function(elem) {
      return elem.clone().transform(Raphael.format("t0,{0}", cell_length * map.grid.rows));
    });
    paper.setStart();
    paper.path(Raphael.format("M{0},{0}l0,{1}", map.border, cell_length * map.grid.rows)).attr("stroke", map.grid.color).attr("stroke-width", map.multiplier * 1);
    for (x = _m = 0, _ref4 = map.grid.rows; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; x = 0 <= _ref4 ? ++_m : --_m) {
      paper.rect(map.border - clearbox.width / 2, map.border + (x - 0.5) * cell_length - clearbox.height / 2, clearbox.width, clearbox.height).attr(clearbox.attr);
    }
    for (x = _n = 1, _ref5 = map.grid.rows; 1 <= _ref5 ? _n <= _ref5 : _n >= _ref5; x = 1 <= _ref5 ? ++_n : --_n) {
      paper.text(map.border, map.border + (x - 0.5) * cell_length, String.fromCharCode(x + 64)).attr("fill", map.grid.color).attr("font-size", map.multiplier * 13);
    }
    return paper.setFinish().forEach(function(elem) {
      return elem.clone().transform(Raphael.format("t{0},0", cell_length * map.grid.columns));
    });
  };

  drawRoute = function(paper, route) {
    var edge, key, value, _i, _len, _ref, _ref1, _results;
    _ref = route.translate;
    for (key in _ref) {
      value = _ref[key];
      route.translate[key] = value * map.multiplier;
    }
    _ref1 = getStartEndPoint(route.edges);
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      edge = _ref1[_i];
      _results.push(drawSolidEdge(paper, edge).transform(Raphael.fullfill("t{x},{y}", route.translate)));
    }
    return _results;
  };

  drawSolidEdge = function(paper, edge) {
    return paper.path(Raphael.fullfill("M{start.x},{start.y}L{end.x},{end.y}", edge)).attr("stroke-width", map.multiplier * 10);
  };

  drawStation = function(paper, station) {
    return console.log(station);
  };

  getStartEndPoint = function(edges) {
    var current, edge, _i, _len, _results;
    current = {
      x: 0,
      y: 0
    };
    _results = [];
    for (_i = 0, _len = edges.length; _i < _len; _i++) {
      edge = edges[_i];
      _results.push({
        start: {
          x: Math.round(edge.follow ? current.x = _results[edge.follow].end.x : current.x),
          y: Math.round(edge.follow ? current.y = _results[edge.follow].end.y : current.y),
          curve: __indexOf.call(edges.slice(1), edge) >= 0 && !(edges[_i - 1].direction === edge.direction) ? edges[_i - 1].direction : void 0
        },
        end: {
          x: current.x += Math.round(edge.length * map.multiplier * Math.sin(edge.direction * (Math.PI / 4))),
          y: current.y += Math.round(edge.length * map.multiplier * -1 * Math.cos(edge.direction * (Math.PI / 4)))
        }
      });
    }
    return _results;
  };

}).call(this);
